<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>HACKER BY ALDI</title>
  <style>
    body {
      background: #000;
      color: #00ff00;
      font-family: monospace;
      margin: 0;
    }
    .terminal {
      padding: 20px;
      height: 100vh;
      overflow-y: auto;
      white-space: pre-wrap;
    }
    .input-line {
      display: flex;
      align-items: center;
      margin-top: 4px;
    }
    .prompt {
      color: #00ff00;
      user-select: none;
    }
    .terminal-input {
      background: transparent;
      border: none;
      color: #00ff00;
      outline: none;
      font-family: monospace;
      font-size: 16px;
      width: 100%;
    }
    .title {
      font-size: 24px;
      font-weight: bold;
      color: #00ff00;
      margin-bottom: 20px;
      font-family: monospace;
      letter-spacing: 3px;
      user-select: none;
      text-transform: uppercase;
    }
    .signal-line {
      display: flex;
      align-items: center;
      margin-top: 6px;
      gap: 10px;
      font-size: 16px;
      user-select: text;
    }
    .checkbox-container {
      width: 14px;
      height: 14px;
      border: 2px solid red;
      border-radius: 4px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      flex-shrink: 0;
    }
    .checkbox-container.checked {
      border-color: #0f0;
      background-color: #0f0;
      cursor: default;
    }
    .checkbox-container input[type="checkbox"] {
      display: none;
    }
    .checkbox-container.checked::after {
      content: "✔";
      color: #000;
      font-weight: bold;
      font-size: 12px;
      user-select: none;
    }
  </style>
</head>
<body>
  <div class="terminal" id="terminal">
    <div class="title">HACKER BY ALDI</div>
    <div>> Step 1: Type market name (e.g., EUR/USD)</div>
    <div>> Step 2: Type timeframe in minutes (e.g., 1)</div><br>
  </div>

  <script>
    const terminal = document.getElementById('terminal');

    const originalMarkets = [
      "USD/BRL (OTC)", "USD/DZD (OTC)", "USD/EGP (OTC)", "USD/INR (OTC)", "NZD/CAD (OTC)",
      "USD/IDR (OTC)", "USD/PKR (OTC)", "USD/COP (OTC)", "USD/ZAR (OTC)", "CAD/CHF (OTC)",
      "USD/NGN (OTC)", "AUD/NZD (OTC)", "EUR/SGD (OTC)", "NZD/JPY (OTC)", "GBP/CHF (OTC)",
      "USD/MXN (OTC)", "USD/PHP (OTC)", "USD/BDT (OTC)", "NZD/CHF (OTC)", "USD/ARS (OTC)",
      "EUR/NZD (OTC)", "NZD/USD (OTC)", "GBP/NZD (OTC)", "AUD/CHF", "AUD/JPY", "CAD/JPY",
      "CHF/JPY", "EUR/CAD", "EUR/CHF", "GBP/USD", "USD/JPY", "EUR/USD", "AUD/CAD", "EUR/AUD",
      "GBP/CAD", "EUR/GBP", "EUR/JPY", "GBP/AUD", "GBP/JPY", "USD/CAD", "USD/CHF", "AUD/USD"
    ];

    function normalizeMarket(market) {
      return market.replace(/[\s\/\(\)]/g, '').toUpperCase();
    }

    const normalizedMarketMap = new Map(originalMarkets.map(m => [normalizeMarket(m), m]));

    let state = { market: null, timeframe: null };

    function createInputLine() {
      const line = document.createElement('div'); 
      line.classList.add('input-line');
      const prompt = document.createElement('span'); 
      prompt.classList.add('prompt'); 
      prompt.innerText = '> ';
      const input = document.createElement('input'); 
      input.classList.add('terminal-input'); 
      input.autofocus = true;
      input.addEventListener('keydown', e => {
        if (e.key === 'Enter') {
          const cmd = input.value.trim();
          if (!cmd) return;
          line.remove();
          addLine(`> ${cmd}`);
          processInput(cmd);
        }
      });
      line.appendChild(prompt); 
      line.appendChild(input);
      terminal.appendChild(line);
      input.focus();
      terminal.scrollTop = terminal.scrollHeight;
    }

    function addLine(text) {
      const line = document.createElement('div');
      line.innerText = text;
      terminal.appendChild(line);
      terminal.scrollTop = terminal.scrollHeight;
    }

    function addSignalLine(text) {
      const line = document.createElement('div');
      line.classList.add('signal-line');

      const checkboxContainer = document.createElement('label');
      checkboxContainer.classList.add('checkbox-container');

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';

      checkbox.addEventListener('change', () => {
        if (checkbox.checked) {
          checkboxContainer.classList.add('checked');
          checkbox.disabled = true;
          checkboxContainer.style.cursor = 'default';
        }
      });

      checkboxContainer.appendChild(checkbox);

      const textSpan = document.createElement('span');
      textSpan.textContent = text;

      line.appendChild(textSpan);
      line.appendChild(checkboxContainer);
      terminal.appendChild(line);
      terminal.scrollTop = terminal.scrollHeight;
    }

    function formatTime(d) {
      return d.toTimeString().slice(0,5);
    }

    // Improved signal logic with multiple random indicators in background
    function generateSignalAdvanced() {
      const smaShort = 1 + Math.random() * 0.5;
      const smaLong = 1 + Math.random() * 0.5;
      const rsi = Math.floor(Math.random() * 61) + 20;
      const macdDiff = (Math.random() - 0.5) * 2;
      const stochastic = Math.random() * 100;

      if (smaShort > smaLong && rsi >= 50 && rsi <= 70 && macdDiff > 0 && stochastic < 80) return 'CALL';

      if (smaShort < smaLong && rsi >= 30 && rsi <= 50 && macdDiff < 0 && stochastic > 20) return 'PUT';

      return Math.random() > 0.55 ? 'CALL' : 'PUT';
    }

    function scheduleFutureSignal(tf) {
      const now = new Date();
      const tfMillis = tf * 60000;
      const nextCandleTime = new Date(Math.ceil(now.getTime() / tfMillis) * tfMillis);
      const signalTime = new Date(nextCandleTime.getTime() - 2 * 60000);
      const delay = signalTime - now;

      const finalSignalTime = formatTime(nextCandleTime);
      const sig = generateSignalAdvanced();

      if (delay <= 0) {
        addSignalLine(`${finalSignalTime} - ${sig} - ${state.market}`);
        reset();
      } else {
        setTimeout(() => {
          addSignalLine(`${finalSignalTime} - ${sig} - ${state.market}`);
          reset();
        }, delay);
      }
    }

    function reset() {
      state.market = null;
      state.timeframe = null;
      createInputLine();
    }

    function processInput(cmd) {
      if (!state.market) {
        const n = normalizeMarket(cmd);
        if (!normalizedMarketMap.has(n)) {
          addLine("❌ Invalid market!");
          createInputLine();
          return;
        }
        state.market = normalizedMarketMap.get(n);
        addLine(`Market set to: ${state.market}`);
        addLine("Type timeframe in minutes (1, 3, 5, 15, 30)");
        createInputLine();
      } else if (!state.timeframe) {
        const tf = parseInt(cmd);
        if (isNaN(tf) || tf <= 0) {
          addLine("❌ Invalid timeframe!");
          createInputLine();
          return;
        }
        state.timeframe = tf;
        addLine(`Timeframe set to: ${state.timeframe} min`);
        addLine(`Waiting for next signal for ${state.market}...`);
        scheduleFutureSignal(tf);
      }
    }

    createInputLine();
  </script>
</body>
</html>
